在 BC 环境下，你可以使用 `bios.h` 中的 `bioskey(int cmd)` 函数访问 BIOS 服务的键盘接口，获取当前键盘状态。

下面介绍参数 cmd 的取值和对应行为。

## 参数和行为
### cmd = 0

当参数 `cmd` 是0时，`bioskey()` 返回下一个在键盘键入的值。也就是说，如果此时没有按键被按下，他将阻塞原有进程并等待下一个按键。

它返回一个16位的二进制数，包括两个不同的值。当按下一个普通键时，它的低8位数存放该字符的 ASCII 码，高8位存放该键的扫描码；对于特殊键（如方向键、F1～F12等等），低8位为0，高8位字节存放该键的扫描码。

例如，你可以通过如下方式获取下一个输入的普通按键的 ASCII 值，并处存在字符变量中：

```c
int k = bioskey(0);
char c = k & 0xff;
```

对于各按键的扫描码值，可以写一个简单程序自行测试并获取，以 enum 或宏定义形式存储在自己的代码中，便于使用。

### cmd = 1

当参数 `cmd` 是1时，可以监测当前输入状态。若没有按键被按下，则返回0。这可以避免 `cmd = 0` 时阻塞原有进程的问题。

不过为了避免按键的一次按下被当成多次输入，我个人建议实现的输入方法如下：
```c
int k;
if(bioskey(1)){
    k = bioskey(0);
}
```

### cmd = 2

当cmd是2，`bioskey()` 返回 `Shift`、`Ctrl`、`Alt`、`ScrollLock`、`NumLock`、`CapsLock`、`Insert`键的状态。各键状态存放在返回值的低8位字节中。

字节位由低到高依次对应：

* 0 右 Shift 键状态
* 1 左 Shift 键状态
* 2 Ctrl 键状态
* 3 Alt 键状态
* 4 ScrollLock 键状态
* 5 NumLock 键状态
* 6 CapsLock 键状态
* 7 Insert 键状态

其中字节位为1表示该键被按下，为0表示松开。